这是一份**技术设计文档 (Technical Design Document - TDD)**。

与需求文档（PRD）不同，这份文档侧重于**“怎么实现”**。它剥离了具体的代码语法，专注于**系统架构、数据流向、模块逻辑和设计决策**。这通常是资深架构师写给开发团队的执行蓝图。

---

# link-ai Backend - 技术设计架构书

| 项目代号 | link-ai |
| --- | --- |
| **文档类型** | Technical Design Document (TDD) |
| **适用角色** | 后端工程师、系统架构师 |
| **核心技术** | Fastify, TypeScript, Prisma, Redis, SSE |

---

## 1. 系统架构概览 (System Architecture)

本系统采用 **分层架构 (Layered Architecture)** 设计，强调关注点分离（SoC）。利用 Node.js 的事件循环机制处理高并发 I/O，将计算密集型任务（如数据分析）留给数据库或上游服务，将逻辑密集型任务（如 Prompt 组装）留在 Service 层。

### 1.1 流量处理链路

1. **接入层 (Entry)**: HTTP 请求进入，首先经过 Nginx (生产环境) 或直接进入 Fastify 实例。
2. **安检层 (Hooks/Plugins)**:
* **Rate Limit**: 检查 Redis 计数器，拦截超频请求。
* **CORS**: 处理跨域。
* **Auth**: 解析 JWT Header，将用户信息挂载到 `request.user` 上。


3. **路由层 (Controller)**: 解析请求参数，校验 Schema (Validation)，分发给对应的 Service。
4. **业务层 (Service)**: 核心业务逻辑（如调用 OpenAI、处理流数据、计算剩余额度）。
5. **数据层 (Data Access)**: 使用 Prisma Client 操作 PostgreSQL；使用 Redis 读写缓存。

---

## 2. 核心模块逻辑设计 (Core Logic Design)

### 2.1 认证模块 (Authentication)

**设计目标**: 无状态鉴权，安全性优先。

* **逻辑流程 - 注册**:
1. 接收 Payload `{ email, password }`。
2. **原子性检查**: 查询 DB 是否存在该 Email。
3. **加盐哈希**: 使用 `bcrypt` 生成 Hash（Salt Rounds = 10）。禁止明文存储。
4. **入库**: 写入 User 表。


* **逻辑流程 - 登录**:
1. 查库获取 User 对象。
2. **比对**: `bcrypt.compare(inputPassword, dbHash)`。
3. **签发**: 生成 JWT，Payload 包含 `{ userId, role }`，有效期设为 7 天。
4. **返回**: Token 字符串。



### 2.2 AI 对话流式模块 (The AI Pipeline)

**设计目标**: 低延迟首字时间 (TTFT)，数据完整性。

* **技术难点**: 如何在保持 HTTP 连接不断开的情况下，一边推流给前端，一边收集完整回复存库。
* **逻辑流程**:
1. **上下文组装**: Service 层根据 `userId` 查询最近 10 条历史记录 (`Chat` 表)，拼接成 OpenAI 格式的 Messages 数组。
2. **建立上游连接**: 调用 LLM API，开启 `stream: true`。
3. **建立下游管道**: 设置 Response Header `Content-Type: text/event-stream`。
4. **双向流处理 (Dual Stream Handling)**:
* *Buffer 变量*: 初始化一个空字符串 `fullResponse = ""`。
* *监听 Chunk*: 每收到一个 AI 字符片段：
* **动作 A**: 立即通过 `response.write()` 推送给前端。
* **动作 B**: 追加到 `fullResponse` 变量中。




5. **结束处理**:
* 当流结束 (`DONE`)，关闭 HTTP 连接。
* **异步落库**: 将完整的 `fullResponse` 连同用户的提问，打包成 JSON，写入 PostgreSQL 的 `Chat` 表。





### 2.3 流量治理模块 (Governance)

**设计目标**: 保护系统资源，防止恶意刷接口。

* **Redis Key 设计**:
* 格式: `rate_limit:{userId}:{api_path}`
* TTL: 60秒


* **逻辑流程**:
1. 请求到达 `onRequest` 钩子。
2. Redis `INCR` (原子递增) 该 Key。
3. 如果是第一次访问 (值为1)，设置 `EXPIRE` 为 60秒。
4. 检查返回值：如果 `> 20` (限流阈值)，直接抛出 `429 Too Many Requests` 错误，中断后续流程。



---

## 3. 数据库模型设计 (Data Modeling)

不展示具体 SQL，展示实体与业务关系。

### 3.1 实体关系 (ER)

* **User (1) ──< (N) Chat**: 一个用户拥有多个对话 Session。
* *设计决策*: 为了简化 MVP，我们将“一条对话记录”定义为“一次完整的问答对 (Q&A Pair)”，而不是像微信那样无限长的 Session。

### 3.2 关键字段逻辑

* **User 表**:
* `password`: 必须是 Hash 字符串，长度固定 (60 chars)。
* `balance`: (扩展字段) 剩余 Token 数，整数类型。


* **Chat 表**:
* `content`: **JSONB 类型**。
* *存储结构*: `[{"role": "user", "content": "..."}, {"role": "assistant", "content": "..."}]`
* *优势*: 利用 Postgres 的 JSONB 能力，既保持 NoSQL 的灵活，又有 SQL 的事务。





---

## 4. API 接口契约 (Interface Contract)

定义前后端交互的“协议”，不仅仅是 URL。

### 4.1 通用规范

* **响应结构 (JSON)**:
```json
{
  "code": 0,          // 0 成功, 非 0 失败
  "data": { ... },    // 业务数据
  "message": "success" // 调试信息
}

```


* **流式响应 (SSE)**:
* 格式: `data: {"content": "我"}\n\n` ... `data: {"content": "是"}\n\n`
* 结束标识: `data: [DONE]\n\n`



### 4.2 错误码设计

* `40001`: 参数校验失败 (Schema Validation Failed)。
* `40100`: Token 无效或过期。
* `40200`: 余额不足 (业务逻辑错误)。
* `50000`: 内部服务异常 (未捕获的 Error)。

---

## 5. 工程与部署规范 (Infrastructure)

### 5.1 目录结构 (Scaffold)

采用 **按功能模块 (Feature-based)** 组织，而非按技术层级。

```
src/
├── modules/
│   ├── auth/           # 认证模块闭环
│   │   ├── auth.schema.ts  # 参数定义
│   │   ├── auth.service.ts # 业务逻辑
│   │   └── auth.route.ts   # 路由入口
│   └── chat/           # 聊天模块闭环
│       └── ...
├── common/             # 公共组件
│   ├── db.ts           # Prisma 实例
│   ├── redis.ts        # Redis 实例
│   └── env.ts          # 环境变量校验
└── app.ts              # Fastify 启动入口

```

### 5.2 环境变量 (.env)

系统启动强依赖以下变量，缺失即报错退出：

* `DATABASE_URL`: Postgres 连接串。
* `REDIS_URL`: Redis 连接地址。
* `JWT_SECRET`: 签名密钥。
* `AI_PROVIDER_KEY`: 大模型 API Key。

### 5.3 部署策略

* **Dockerization**: 使用 Multi-stage Build。
* *Build Stage*: 安装全部依赖，编译 TS -> JS。
* *Production Stage*: 只安装 `production` 依赖，复制 `/dist` 目录，体积最小化。


* **PM2**: 容器内使用 PM2 或直接 `node` 启动，配合 Docker Restart Policy 实现自愈。

---

## 6. 开发路线图 (Implementation Plan)

1. **Phase 0: 骨架搭建**
* 初始化 TS + Fastify。
* 配置 ESLint/Prettier。
* 跑通 Docker Compose (DB + Redis)。


2. **Phase 1: 数据层与鉴权**
* 定义 Prisma Schema。
* 实现 Auth 注册/登录逻辑。
* 验证 JWT 中间件。


3. **Phase 2: 核心 AI 业务**
* 集成 OpenAI SDK。
* 攻克 SSE 流式输出难点。
* 实现对话入库。


4. **Phase 3: 治理与优化**
* 接入 Redis 限流。
* 完善 Request/Response Schema 校验。
* 统一错误拦截处理。



---

**这份技术文档是否符合你对“成品逻辑”的构想？**
如果确认无误，我们就可以按照 **Phase 0** 开始动手写代码了。